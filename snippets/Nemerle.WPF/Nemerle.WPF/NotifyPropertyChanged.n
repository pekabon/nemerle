using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;
using System.ComponentModel;

namespace Nemerle.WPF
{
    [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class, Inherited = false, AllowMultiple = false)]  
    public macro NotifyPropertyChanged(tb : TypeBuilder, raisePropertyChangedMethod = null)
    {
        ignore(raisePropertyChangedMethod);

        NotifyPropertyChangedHelper.AddInterface(tb);
    }

    [MacroUsage(MacroPhase.BeforeTypedMembers, MacroTargets.Class, Inherited = false, AllowMultiple = false)]  
    public macro NotifyPropertyChanged(tb : TypeBuilder, raisePropertyChangedMethod = <[ () ]>)
    {
        NotifyPropertyChangedHelper.ImplementInterface(Macros.ImplicitCTX(), 
                                                       tb, 
                                                       raisePropertyChangedMethod = raisePropertyChangedMethod,
                                                       macroName                  = GetName().Split(':')[0]);
    }

    [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class, Inherited = false, AllowMultiple = false)]  
    public macro NotifyPropertyChanged(tb : TypeBuilder, raisePropertyChangedMethod =  <[ () ]>)
    {
        ignore(raisePropertyChangedMethod);

        NotifyPropertyChangedHelper.FixProperties(tb);
    }

    public macro RaisePropertyChanged(expr, raisePropertyChangedMethod = <[ () ]>)
    {
        NotifyPropertyChangedHelper.RaisePropertyChanged(Macros.ImplicitCTX().CurrentTypeBuilder,
                                                         propName = (expr :> PExpr.Ref).name.Id,
                                                         raisePropertyChangedMethod = raisePropertyChangedMethod);
    }

    [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Property, Inherited = false, AllowMultiple = false)]  
    public macro NotifyPropertyChangedIgnore(tb : TypeBuilder, property : ParsedProperty)
    {
        NotifyPropertyChangedHelper.RegisterIgnored(tb, property);
    }

    module NotifyPropertyChangedHelper
    {       
        public AddInterface(tb : TypeBuilder) : void
        {
            tb.AddImplementedInterface(<[ System.ComponentModel.INotifyPropertyChanged ]>);
        }

        public ImplementInterface(typer                    : Typer, 
                                tb                         : TypeBuilder, 
                                raisePropertyChangedMethod : PExpr, 
                                macroName                  : string) : void
        {
            Macros.DefineCTX(typer);

            when (tb.IsDelegate  || 
                  tb.IsEnum      || 
                  tb.IsInterface || 
                  tb.IsModule)
                    Message.Error(tb.Location, 
                        $"Macro $macroName is not valid on this declaration type. It is only valid on 'class' declarations.");

            def interfaceAlreadyImplemented    = tb.BaseClass.TryRequire(<[ ttype: System.ComponentModel.INotifyPropertyChanged ]>);
            def raisePropertyChangedMethodSpecified = !(raisePropertyChangedMethod is <[ () ]>);
            
            when(interfaceAlreadyImplemented && !raisePropertyChangedMethodSpecified)
            {
                Message.Error(tb.Location, 
                    "Please specify method for property changed event raising (e.g. [NotifyPropertyChanged(RaisePropChanged)]).");
            }
            
            unless(interfaceAlreadyImplemented)
            {
                tb.Define(<[ decl: public event PropertyChanged : PropertyChangedEventHandler; ]>);
            }

            unless(raisePropertyChangedMethodSpecified)
            {
                def raisePropertyChangedMethodDecl = <[ decl:
                            protected RaisePropertyChangedCore(propertyName: string) : void
                            {
                                def handler = PropertyChanged;
                                when (handler != null)
                                    handler(this, PropertyChangedEventArgs(propertyName));
                            }
                    ]>;
                tb.Define(raisePropertyChangedMethodDecl);
            }
            
            tb.UserData[_userDataKey] = (interfaceAlreadyImplemented, 
                                         raisePropertyChangedMethod);
        }

        public RaisePropertyChanged(tb : TypeBuilder, propName : string, raisePropertyChangedMethod : PExpr) : PExpr
        {
            assert2(false);
            
            when(raisePropertyChangedMethod is <[ () ]> && !tb.UserData.Contains(_userDataKey))
                Message.Error(raisePropertyChangedMethod.Location, "Expected simple name");

            def raisePropertyChangedMethodName =  match(raisePropertyChangedMethod)
                                                    {
                                                        | <[ $(raisePropertyChangedMethodName : name) ]> => raisePropertyChangedMethodName
                                                        | _ => 
                                                               Message.Error(raisePropertyChangedMethod.Location, "Expected simple name");
                                                               Name("RaisePropertyChangedCore")
                                                    };

            match(tb.GetProperties().Filter(prop => prop.Name == propName))
            {
                | [] => Message.Error($"Class '$(tb.FullName)' does not contain a property with the name '$propName'.");
                        <[]>
                | _  => <[ $(raisePropertyChangedMethodName : name)($(propName : string)); ]>
            }
        }

        public FixProperties(tb : TypeBuilder) : void
        {
            def properties = tb.GetProperties().Filter(property => !_ignoredProperties.Contains(tb, property.Name));

            foreach(property is PropertyBuilder in properties)
            {
                match(property.GetSetter())
                {
                    | setter is MethodBuilder => 
                        def loc = setter.Body;
                        setter.Body = <[ $(setter.Body);
                                        RaisePropertyChangedCore($(property.Name : string)); ]>;
                        setter.Body = loc;
                    | _ => ()
                }
            }
        }

        public RegisterIgnored(tb : TypeBuilder, property : ClassMember.Property) : void
        {
            _ = _ignoredProperties.Add(tb, property.Name);
        }

        private _ignoredProperties = SCG.HashSet.[TypeBuilder * string]();
        private _userDataKey = Guid.NewGuid();
    }
}
