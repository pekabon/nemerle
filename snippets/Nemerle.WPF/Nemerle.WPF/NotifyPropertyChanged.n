using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;
using System.ComponentModel;

namespace Nemerle.WPF
{
    using NotifyPropertyChangedHelper;

    [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class, Inherited = false, AllowMultiple = false)]  
    public macro NotifyPropertyChanged(tb : TypeBuilder, raisePropertyChangedMethod = null)
    {
        ignore(raisePropertyChangedMethod);

        AddInterface(tb);
    }

    [MacroUsage(MacroPhase.BeforeTypedMembers, MacroTargets.Class, Inherited = false, AllowMultiple = false)]  
    public macro NotifyPropertyChanged(tb : TypeBuilder, raisePropertyChangedMethod = <[ () ]>)
    {
        ImplementInterface(Macros.ImplicitCTX(), 
                           tb, 
                           raisePropertyChangedMethod,
                           GetName() |> UndecorateMacroName);
    }

    [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Class, Inherited = false, AllowMultiple = false)]  
    public macro NotifyPropertyChanged(tb : TypeBuilder, raisePropertyChangedMethod =  <[ () ]>)
    {
        ignore(raisePropertyChangedMethod);

        FixProperties(tb, GetName() |> UndecorateMacroName);
    }

    public macro RaisePropertyChanged(property : PExpr, raisePropertyChangedMethod = <[ () ]>)
    {
        RaisePropertyChanged(Macros.ImplicitCTX().CurrentTypeBuilder,
                             property,
                             raisePropertyChangedMethod,
                             GetName() |> UndecorateMacroName);
    }

    [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Property, Inherited = false, AllowMultiple = false)]  
    public macro NotifyPropertyChangedIgnore(tb : TypeBuilder, property : ParsedProperty)
    {
        RegisterIgnored(tb, property);
    }

    module NotifyPropertyChangedHelper
    {       
        public AddInterface(tb : TypeBuilder) : void
        {
            tb.AddImplementedInterface(<[ System.ComponentModel.INotifyPropertyChanged ]>);
        }

        public ImplementInterface(typer                    : Typer, 
                                tb                         : TypeBuilder, 
                                raisePropertyChangedMethod : PExpr, 
                                macroName                  : string) : void
        {
            Macros.DefineCTX(typer);

            when (tb.IsDelegate  || 
                  tb.IsEnum      || 
                  tb.IsInterface || 
                  tb.IsModule)
                Message.Error(tb.Location, 
                              $"Macro $macroName is not valid on this declaration type. It is only valid on 'class' declarations.");

            def interfaceAlreadyImplemented = tb.BaseClass.TryRequire(<[ ttype: System.ComponentModel.INotifyPropertyChanged ]>);

            def raiseMethodName =  match(raisePropertyChangedMethod)
                                                    {
                                                        | <[ $(raisePropertyChangedMethodName : name) ]> => raisePropertyChangedMethodName
                                                        | <[()]> => Name("OnPropertyChanged")
                                                        | _ =>  Message.Error(tb.Location, 
                                                                $"Specify a valid method for property changed event raising (e.g. $macroName(PropName, OnPropertyChanged)).");
                                                                Name("OnPropertyChanged")
                                                    };

            unless (interfaceAlreadyImplemented)
            {
                tb.Define(<[ decl: public event PropertyChanged : System.ComponentModel.PropertyChangedEventHandler; ]>);

                def raiseMethodDecl = <[ decl:
                                    protected virtual $(raiseMethodName : name)(propertyName: string) : void
                                    {
                                        def handler = PropertyChanged;
                                        when (handler != null)
                                            handler(this, System.ComponentModel.PropertyChangedEventArgs(propertyName));
                                    }
                            ]>;

                tb.Define(raiseMethodDecl);
            }

            tb.UserData[_userDataKey] = raiseMethodName;
        }

        public RaisePropertyChanged(tb : TypeBuilder, property : PExpr, raisePropertyChangedMethod : PExpr, macroName : string) : PExpr
        {
            def OnError(message)
            {
                Message.Error(raisePropertyChangedMethod.Location, message);
                <[]>
            }
                
            def CreateRaiseMethod(propName, methodNameLazy)
            {
                match(tb.GetProperties().Filter(prop => prop.Name == propName))
                {
                   | [_] => methodNameLazy.Value.Map(methodName => <[ $(methodName : name)($(propName : string)); ]>) 
                            ?? OnError($"Specify a valid method for property changed event raising (e.g. $macroName(PropName, OnPropertyChanged)).")
                   | []  => OnError($"Class '$(tb.FullName)' does not contain a property with the name '$propName'.")
                }
            }

            def methodName = lazy(
            {
                match(raisePropertyChangedMethod)
                {
                    | <[ $(raiseMethodName : name) ]>                with name = raiseMethodName
                    | <[()]> when tb.UserData.Contains(_userDataKey) with name = tb.UserData[_userDataKey] :> Name
                        => if (tb.MethodExists(name)) Some(name) else None()
                    | _  => None()
                }
            }
            );

            match(property)
            {
                | propExpr is PExpr.Ref with propName = propExpr.name.Id => 
                        CreateRaiseMethod(propName, methodName)
                | _ => OnError($"Specify a property for changed event raising (e.g. $macroName(PropName)).")
            }
        }

        public FixProperties(tb : TypeBuilder, macroName : string) : void
        {
            def raiseMethodName = tb.UserData[_userDataKey] :> Name;

            if(!tb.MethodExists(raiseMethodName))
            {
                Message.Error(tb.Location, 
                              $"Specify a valid method for property changed event raising (e.g. [$macroName(OnPropertyChanged)]).");
            }
            else
            {
                def properties = tb.GetProperties(BindingFlags.DeclaredOnly | 
                                                  BindingFlags.Instance     | 
                                                  BindingFlags.Public       | 
                                                  BindingFlags.NonPublic).
                                    Filter(property => !_ignoredProperties.Contains(tb, property.Name));

                foreach(propertyBuilder is PropertyBuilder in properties)
                {
                    match(propertyBuilder.GetSetter())
                    {
                        | setter is MethodBuilder => 
                            def loc = setter.Body.Location;
                            setter.Body = <[ $(setter.Body);
                                            $(raiseMethodName : name)($(propertyBuilder.Name : string)); ]>;
                            setter.Body.Location = loc;
                        | _ => ()
                    }
                }
            }
        }

        public RegisterIgnored(tb : TypeBuilder, property : ClassMember.Property) : void
        {
            _ = _ignoredProperties.Add(tb, property.Name);
        }

        public UndecorateMacroName(decoratedMacroName : string) : string
        {
            decoratedMacroName.Split(':').First()
        }
        
        private MethodExists(this tb : TypeBuilder, raisePropertyChangedMethodName : Name) : bool
        {
            tb.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).
                                         Exists(method => method.Name == raisePropertyChangedMethodName.Id)
            
        }

        private _ignoredProperties = SCG.HashSet.[TypeBuilder * string]();
        private _userDataKey = Guid.NewGuid();
    }
}
